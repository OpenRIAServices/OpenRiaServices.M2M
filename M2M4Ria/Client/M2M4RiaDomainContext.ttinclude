<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#
//
// Change the file path below to the path of the M2M4RiaShared.ttinclude in your project
//
#>
<#@ include file="..\Shared\M2M4RiaShared.ttinclude" #>
<#

M2MData m2mData = GenerateM2MData();

#>

// Instruct compiler not to warn about usage of obsolete members, because using them is intended.
#pragma warning disable 618

#region Domain Context

namespace <#= DomainServiceNamespace #>
{
    using System.ServiceModel.DomainServices.Client;
    using <#= EntityModelNamespace #>;

    public partial class <#= DomainContextName #>
    {
<#
    if(IsJoinTypeEntitySetAccessibleFromDomainContext == true)
    {
            foreach(M2MAssociationSet associationSet in m2mData.Associations)
            {
                CreateEntitySetPropertyForJoinType(associationSet);
            }
    }
#>
        partial void OnCreated()
        {
            // Install handlers that set/reset EntitySet properties of link table entities when they are
            // added/removed from the domain context's entity sets. This is only needed as long as RIA
            // doesn't provide access from an Entity to its EntitySet.
<#
            foreach(M2MAssociationSet associationSet in m2mData.Associations)
            {
                CreateEntitySetSetter(associationSet);
            }
#>
        }
    }
}

#endregion

namespace <#= EntityModelNamespace #>
{
    #region Entities

    using System;
    using System.ServiceModel.DomainServices.Client;

    using M2M4Ria;

<#
    foreach(M2MAssociationSet associationSet in m2mData.Associations)
    {
        CreateAssociation(associationSet);
    }
    foreach(M2MEntity entity in m2mData.Entities)
    {
        CreateEntity(entity);
    }
#>
    #endregion

    #region EntityCollection

    namespace M2M4Ria
    {
        using System;
        using System.Collections;
        using System.Collections.Generic;
        using System.Collections.Specialized;
        using System.ComponentModel;
        using System.Linq;
        using System.ServiceModel.DomainServices.Client;

        /// <summary>
        /// Defines methods for manipulation a generic EntityCollection
        /// </summary>
        /// <typeparam name="TEntity">The type of the elements in the collection</typeparam>
        public interface IEntityCollection<TEntity> : IEnumerable<TEntity>, IEnumerable, INotifyCollectionChanged, INotifyPropertyChanged
        {
            /// <summary>
            /// Gets the current count of entities in this collection
            /// </summary>
            int Count { get; }
            /// <summary>
            /// Event raised whenever an System.ServiceModel.DomainServices.Client.Entity
            /// is added to this collection
            /// </summary>
            event EventHandler<EntityCollectionChangedEventArgs<TEntity>> EntityAdded;
            /// <summary>
            /// Event raised whenever an System.ServiceModel.DomainServices.Client.Entity
            /// is removed from this collection
            /// </summary>
            event EventHandler<EntityCollectionChangedEventArgs<TEntity>> EntityRemoved;
            /// <summary>
            /// Add the specified entity to this collection. If the entity is unattached,
            /// it will be added to its System.ServiceModel.DomainServices.Client.EntitySet
            /// automatically.
            /// </summary>
            /// <param name="entity"> The entity to add</param>
            void Add(TEntity entity);
            /// <summary>
            /// Remove the specified entity from this collection.
            /// </summary>
            /// <param name="entity">The entity to remove</param>
            void Remove(TEntity entity);
        }

        /// <summary>
        /// M2M-specific entity collection class. It vorms a view on the underlying jointable collection.
        /// </summary>
        /// <typeparam name="JoinType"></typeparam>
        /// <typeparam name="TEntity"></typeparam>
        public class EntityCollection<JoinType, TEntity> : IEntityCollection<TEntity>
            where JoinType : Entity, new()
            where TEntity : Entity
        {
            EntityCollection<JoinType> collection;
            Func<JoinType, TEntity> getEntity;
            Action<JoinType> removeAction;
			Action<TEntity> addAction;
            /// <summary>
            ///
            /// </summary>
            /// <param name="collection">The collection of associations to which this collection is connected</param>
            /// <param name="getEntity">The function used to get the entity object out of a join type entity</param>
            /// <param name="setEntity">The function used to set the entity object in a join type entity</param>
            public EntityCollection(
				EntityCollection<JoinType> collection,
				Func<JoinType, TEntity> getEntity,
                Action<JoinType> removeAction,
				Action<TEntity> addAction)
            {
                this.collection = collection;
                this.getEntity = getEntity;
                this.removeAction = removeAction;
                this.addAction = addAction;

                collection.EntityAdded += (a, b) =>
                {
                    JoinType jt = b.Entity as JoinType;
                    if (EntityAdded != null)
                        EntityAdded(this, new EntityCollectionChangedEventArgs<TEntity>(getEntity(jt)));
                };
                collection.EntityRemoved += (a, b) =>
                {
                    JoinType jt = b.Entity as JoinType;
                    if (EntityRemoved != null)
                        EntityRemoved(this, new EntityCollectionChangedEventArgs<TEntity>(getEntity(jt)));
                };
                ((INotifyCollectionChanged)collection).CollectionChanged += (sender, e) =>
                {
                    if (CollectionChanged != null)
                        CollectionChanged(this, MakeNotifyCollectionChangedEventArgs(e));
                };
                ((INotifyPropertyChanged)collection).PropertyChanged += (sender, e) =>
                {
                    if (PropertyChanged != null)
                        PropertyChanged(this, e);
                };
            }

            /// <summary>
            /// Replaces JoinType elements in NotifyCollectionChangedEventArgs by elements of type TEntity
            /// </summary>
            /// <param name="e"></param>
            /// <returns></returns>
            private NotifyCollectionChangedEventArgs MakeNotifyCollectionChangedEventArgs(NotifyCollectionChangedEventArgs e)
            {
                switch (e.Action)
                {
                    case NotifyCollectionChangedAction.Add:
                        {
                            TEntity entity = getEntity((JoinType)e.NewItems[0]);
                            return new NotifyCollectionChangedEventArgs(e.Action, entity, indexOfChange);
                        }
                    case NotifyCollectionChangedAction.Remove:
                        {
                            TEntity entity = getEntity((JoinType)e.OldItems[0]);
                            return new NotifyCollectionChangedEventArgs(e.Action, entity, indexOfChange);
                        }
                    case NotifyCollectionChangedAction.Reset:
                        return new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset);
                }
                throw new Exception(String.Format("NotifyCollectionChangedAction.{0} action not supported by M2M4Ria.EntityCollection", e.Action.ToString()));
            }

            public IEnumerator<TEntity> GetEnumerator()
            {
                return collection.Select(getEntity).GetEnumerator();
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                return this.GetEnumerator();
            }

            public int Count
            {
                get
                {
                    return collection.Count;
                }
            }

            private int IndexOf(TEntity entity)
            {
                int index = 0;
                foreach(TEntity e in this){
                    if(e == entity)
                        return index;
                    index++;
                }
                return -1;
            }

            // Indicates the index where a change of the collection occurred.
            private int indexOfChange;

            public void Add(TEntity entity)
            {
			    addAction(entity);
            }

            /// <summary>
            /// Use remove on the entityset on the domain context, rather than this functioln
            /// There seems to be a limitation of RIA which requires that associations should be deleted on the domain context
            /// </summary>
            /// <param name="entity"></param>
            public void Remove(TEntity entity)
            {
                indexOfChange = IndexOf(entity);
                JoinType joinTypeToRemove = collection.SingleOrDefault(jt => getEntity(jt) == entity);
                if (joinTypeToRemove != null)
                    removeAction(joinTypeToRemove);
            }

            public event EventHandler<EntityCollectionChangedEventArgs<TEntity>> EntityAdded;
            public event EventHandler<EntityCollectionChangedEventArgs<TEntity>> EntityRemoved;
            public event NotifyCollectionChangedEventHandler CollectionChanged;
            public event PropertyChangedEventHandler PropertyChanged;
        }
    }
    #endregion
}

// Restore compiler warnings when using obsolete methods
#pragma warning restore 618
<#+
    private void CreateEntitySetPropertyForJoinType(M2MAssociationSet associationSet)
    {
#>
        /// <summary>
        /// Gets the set of <see cref="<#=associationSet.Name#>"/> entities that have been loaded into this <see cref="<#=DomainContextName#>"/> instance.
        /// </summary>
        public EntitySet<<#=associationSet.Name#>> <#=associationSet.Name#>s
        {
            get
            {
                return base.EntityContainer.GetEntitySet<<#=associationSet.Name#>>();
            }
        }
<#+
    }
    private void CreateEntitySetSetter(M2MAssociationSet associationSet)
    {
        string entitySetName = associationSet.Name + "EntitySet";
        if(associationSet.Entity1ToLink.HasM2MNavProp || associationSet.Entity2ToLink.HasM2MNavProp)
        {
#>
            EntitySet< <#=associationSet.Name #> > <#=entitySetName#> = EntityContainer.GetEntitySet< <#=associationSet.Name#>>();
            <#=entitySetName#>.EntityAdded += (sender, args) => args.Entity.EntitySet = <#=entitySetName#>;
            <#=entitySetName#>.EntityRemoved += (sender, args) => args.Entity.EntitySet = null;

<#+
        }
    }
	private void CreateAssociationMethod(string m2mName, M2MAssociation a1, M2MAssociation a2)
	{
	   string a1Entity = a1.Entity.Name;
	   string a1EntityLowerInitial = LowerInitial(a1.Entity.Name);
	   string a2Entity = a2.Entity.Name;
	   string a2EntityLowerInitial = LowerInitial(a2.Entity.Name);
#>
        /// <summary>
        /// This method attaches <#=a1Entity#> and <#=a2Entity#> to the current join table entity, in such a way
        /// that both navigation properties are set before an INotifyCollectionChanged event is fired.
        /// </summary>
        /// <param name="r"></param>
        /// <param name="<#=a1EntityLowerInitial#>"></param>
        /// <param name="<#=a2EntityLowerInitial#>"></param>
        [Obsolete("This property is only intended for use by the M2M4Ria solution.")]
        public static void Attach<#=a2Entity#>To<#=a1Entity#>(<#=m2mName#> r, <#=a1Entity#> <#=a1EntityLowerInitial#>, <#=a2Entity#> <#=a2EntityLowerInitial#>)
        {
            var dummy = r.<#=a2Entity#>; // this is to instantiate the EntityRef<<#=a2Entity#>>
            r._<#=a2EntityLowerInitial#>.Entity = <#=a2EntityLowerInitial#>;
            r._<#=LowerInitial(a2.FK)#> = <#=a2EntityLowerInitial#>.<#=a2.PK#>;

            r.<#=a1Entity#> = <#=a1EntityLowerInitial#>;

            r._<#=a2EntityLowerInitial#>.Entity = null;
            r._<#=LowerInitial(a2.FK)#> = default(<#=a2.DataType#>);
            r.<#=a2Entity#> = <#=a2EntityLowerInitial#>;
        }
<#+
	}
    private void CreateAssociation(M2MAssociationSet associationSet)
    {
        if(associationSet.Entity1ToLink.HasM2MNavProp || associationSet.Entity2ToLink.HasM2MNavProp)
        {
#>
    /// <summary>
    /// This class provides access to the entity's entity set and contains methods for attaching
	/// to entities to the link table in a single action.
    /// </summary>
    public partial class <#=associationSet.Name #>
    {
<#+
CreateAssociationMethod(associationSet.Name, associationSet.Entity1ToLink, associationSet.Entity2ToLink);
CreateAssociationMethod(associationSet.Name, associationSet.Entity2ToLink, associationSet.Entity1ToLink);
#>
        /// <summary>
        /// Gets or sets the EntitySet the link table entity is contained in. It is set by the domain context
        /// when the link entity is added to an entity set, and reset to null when it is removed from an entity set.
		/// This method is only needed as long as RIA doesn't provide this access it self.
        /// </summary>
        [Obsolete("This property is only intended for use by the M2M4Ria solution.")]
        public EntitySet<<#=associationSet.Name#>> EntitySet{ get; set; }
    }
<#+
        }
    }

    private void CreateEntity(M2MEntity entity)
    {
#>
    public partial class <#= entity.Name #>
    {
<#+
        foreach(M2MEntityAssociationSet association in entity.Associations)
        {
            if(association.ThisEntityToLink.HasM2MNavProp)
            {
                string removeMethod = "Remove" + association.Name;
                string addMethod = "Add" + association.Name;
#>
        //
        // Code relating to the managing of the '<#= association.Name #>' association from '<#= association.ThisEntityToLink.Entity #>' to '<#= association.OtherEntityToLink.Entity #>'
        //
        private IEntityCollection<<#= association.OtherEntityToLink.Entity #>> _<#= association.ThisEntityToLink.M2MNavProp #>;

        public IEntityCollection<<#= association.OtherEntityToLink.Entity #>> <#= association.ThisEntityToLink.M2MNavProp #>
        {
            get
            {
                if(_<#= association.ThisEntityToLink.M2MNavProp #> == null)
                {
                    _<#= association.ThisEntityToLink.M2MNavProp #> = new EntityCollection<<#=association.Name#>, <#=association.OtherEntityToLink.Entity#>>(
						this.<#= association.OtherEntityToLink.LinkTableNavProp #>,
						r => r.<#= association.OtherEntityToLink.Entity #>,
						<#= removeMethod #>,
						<#= addMethod #>
				    );
                }
                return _<#= association.ThisEntityToLink.M2MNavProp #>;
            }
        }

        private void <#= addMethod #>(<#= association.OtherEntityToLink.Entity  #> <#= LowerInitial(association.OtherEntityToLink.Entity.Name)#>)
		{
            var newJoinType = new <#= association.Name #>();
            <#= association.Name #>.Attach<#= association.OtherEntityToLink.Entity #>To<#= association.ThisEntityToLink.Entity #>(newJoinType, this, <#= LowerInitial(association.OtherEntityToLink.Entity.Name)#>);
		}
        private void <#= removeMethod #>(<#= association.Name #> r)
        {
            if(r.EntitySet == null)
            {
                this.<#= association.OtherEntityToLink.LinkTableNavProp #>.Remove(r);
            }
            else
            {
                r.EntitySet.Remove(r);
            }
        }
<#+
            }
        }
#>
    }
<#+
    }
	private string LowerInitial(string name)
	{
	   return name[0].ToString().ToLowerInvariant() + name.Substring(1);
	}
#>




