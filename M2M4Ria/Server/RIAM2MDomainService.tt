<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#   
//
// Change the file path below to the path of the RIAM2MShared.ttinclude in your project
//
#>
<#@ include file="$(SolutionDir)\M2M4Ria\Shared\RIAM2MShared.ttinclude" #>
<#

M2MData m2mData = GenerateM2MData();

#> 

#pragma warning disable 618

#region Domain Service

namespace <#= DomainServiceNamespace #>
{
	using System;
	using System.Linq;
	using System.Data;
	using System.Data.Objects;
	using <#= EntityModelNamespace #>;
	
	public partial class <#= DomainServiceName #>
	{
<# 
		foreach(M2MAssociationSet associationSet in m2mData.Associations)
		{
			// If the entities on either side of the M2M relationship don't have a navigation property to each other, then there is no need to output this.
			if(associationSet.Entity1ToLink.HasM2MNavProp || associationSet.Entity2ToLink.HasM2MNavProp)
			{
				// Retrieve the concrete type that will be used for each end of the many to many relationships.
				//
				// Note: In the situation where the entity that we are dealing with is abstract, then use one of it's 
				// derived entities to act as the concrete type for the end.  A derived entity is used in this situation 
				// because you can't instantiate an abstract entity.  The derived entity that you use is not important,
				// since all derived entities will posses the same many to many relationship from the base entity.
				string end1ConcreteEntity = associationSet.Entity1ToLink.Entity.IsAbstract ? associationSet.Entity1ToLink.Entity.DerivedEntityNames[0] : associationSet.Entity1ToLink.Entity.Name;
				string end2ConcreteEntity = associationSet.Entity2ToLink.Entity.IsAbstract ? associationSet.Entity2ToLink.Entity.DerivedEntityNames[0] : associationSet.Entity2ToLink.Entity.Name;
#>
		[Obsolete("This method is only intended for use by the RIA M2M solution")]
		public IQueryable<<#= associationSet.Name #>> Get<#= associationSet.Name #>Query()
		{
			throw new System.NotImplementedException();
		}
		
		[Obsolete("This method is only intended for use by the RIA M2M solution")]
		public void Insert<#= associationSet.Name #>(<#= associationSet.Name #> linkEntity)
		{
			// ** Process <#= associationSet.Entity1ToLink.Entity.Name #> end **
			<#= associationSet.Entity1ToLink.Entity.Name #> end1Entity;
			
			if (linkEntity.<#= associationSet.Entity1ToLink.Entity.Name #> != null)
			{
				// If a reference of <#= associationSet.Entity1ToLink.Entity.Name #> is in the linkEntity that has been passed to this method, then get it.
				end1Entity = linkEntity.<#= associationSet.Entity1ToLink.Entity.Name #>;
			}
            else
            {
                // If there is no reference to <#= associationSet.Entity1ToLink.Entity.Name #> in the linkEntity, then build <#= associationSet.Entity1ToLink.Entity.Name #> from the <#= associationSet.Entity1ToLink.FK #> that has been passed in the linkEntity.
				//
				// Note: In the situation where the entity that we are dealing with is abstract, then use one of it's 
				// derived entities to act as the concrete type for the end.  A derived entity is used in this situation 
				// because you can't instantiate an abstract entity.  The derived entity that you use is not important,
				// since all derived entities will posses the same many to many relationship from the base entity.
                end1Entity = new <#= end1ConcreteEntity  #>() { <#= associationSet.Entity1ToLink.PK #> = linkEntity.<#= associationSet.Entity1ToLink.FK #> };
            }
			
			ObjectStateEntry end1StateEntry;
			
			// Check to see if <#= associationSet.Entity1ToLink.Entity.Name #> is already being tracked by they current entity framework object context.
            ObjectContext.ObjectStateManager.TryGetObjectStateEntry(end1Entity, out end1StateEntry);

			if (end1StateEntry != null && end1StateEntry.State != EntityState.Detached)
            {
                // If <#= associationSet.Entity1ToLink.Entity.Name #> is already being tracked by the object context, then use the instance of <#= associationSet.Entity1ToLink.Entity.Name #> that is being tracked instead of the current <#= associationSet.Entity1ToLink.Entity.Name #>
                end1Entity = end1StateEntry.Entity as <#= associationSet.Entity1ToLink.Entity.Name #>;
            }
            else
            {
                // If <#= associationSet.Entity1ToLink.Entity.Name #> is not being tracked by the object context, then attach it.
                ObjectContext.AttachTo("<#= associationSet.Entity1ToLink.Entity.EntitySet #>", end1Entity);
            }
				
				
			// ** Process <#= associationSet.Entity2ToLink.Entity.Name #> **
            <#= associationSet.Entity2ToLink.Entity.Name #> end2Entity;

            if (linkEntity.<#= associationSet.Entity2ToLink.Entity.Name #> != null)
            {
                // If a reference of <#= associationSet.Entity2ToLink.Entity.Name #> is in the linkEntity that has been passed to this method, then get it.
                end2Entity = linkEntity.<#= associationSet.Entity2ToLink.Entity.Name #>;
            }
            else
            {
                // If there is no reference to <#= associationSet.Entity2ToLink.Entity.Name #> in the linkEntity, then build <#= associationSet.Entity2ToLink.Entity.Name #> from the <#= associationSet.Entity2ToLink.FK #> that has been passed in the linkEntity.
                //
				// Note: In the situation where the entity that we are dealing with is abstract, then use one of it's 
				// derived entities to act as the concrete type for the end.  A derived entity is used in this situation 
				// because you can't instantiate an abstract entity.  The derived entity that you use is not important,
				// since all derived entities will posses the same many to many relationship from the base entity.
				end2Entity = new <#= end2ConcreteEntity #>() { <#= associationSet.Entity2ToLink.PK #> = linkEntity.<#= associationSet.Entity2ToLink.FK #> };
            }
		
			ObjectStateEntry end2StateEntry;

            // Check to see if <#= associationSet.Entity2ToLink.Entity.Name #> is already being tracked by they current entity framework object context.
            ObjectContext.ObjectStateManager.TryGetObjectStateEntry(end2Entity, out end2StateEntry);

            if (end2StateEntry != null && end2StateEntry.State != EntityState.Detached)
            {
                // If <#= associationSet.Entity2ToLink.Entity.Name #> is already being tracked by the object context, then use the instance of <#= associationSet.Entity2ToLink.Entity.Name #> that is being tracked instead of the current <#= associationSet.Entity2ToLink.Entity.Name #>
                end2Entity = end2StateEntry.Entity as <#= associationSet.Entity2ToLink.Entity.Name #>;
            }
            else
            {
                // If <#= associationSet.Entity2ToLink.Entity.Name #> is not being tracked by the object context, then attach it.
                ObjectContext.AttachTo("<#= associationSet.Entity2ToLink.Entity.EntitySet #>", end2Entity);
            }
	
            // ** Add Relationship **
<# 
				if(associationSet.Entity1ToLink.HasM2MNavProp)
				{
#>
			end1Entity.<#= associationSet.Entity1ToLink.M2MNavProp #>.Add(end2Entity);
<#
				}
				else
				{
#>
			end2Entity.<#= associationSet.Entity2ToLink.M2MNavProp #>.Add(end1Entity);
<#
				}
#>
		}
		
		[Obsolete("This method is only intended for use by the RIA M2M solution")]
		public void Delete<#= associationSet.Name #>(<#= associationSet.Name #> linkEntity)
		{
			// ** Process <#= associationSet.Entity1ToLink.Entity.Name #> end **
			<#= associationSet.Entity1ToLink.Entity.Name #> end1Entity;
			
			if (linkEntity.<#= associationSet.Entity1ToLink.Entity.Name #> != null)
			{
				// If a reference of <#= associationSet.Entity1ToLink.Entity.Name #> is in the linkEntity that has been passed to this method, then get it.
				end1Entity = linkEntity.<#= associationSet.Entity1ToLink.Entity.Name #>;
			}
            else
            {
                // If there is no reference to <#= associationSet.Entity1ToLink.Entity.Name #> in the linkEntity, then build <#= associationSet.Entity1ToLink.Entity.Name #> from the <#= associationSet.Entity1ToLink.FK #> that has been passed in the linkEntity.
                //
				// Note: In the situation where the entity that we are dealing with is abstract, then use one of it's 
				// derived entities to act as the concrete type for the end.  A derived entity is used in this situation 
				// because you can't instantiate an abstract entity.  The derived entity that you use is not important,
				// since all derived entities will posses the same many to many relationship from the base entity.
				end1Entity = new <#= end1ConcreteEntity  #>() { <#= associationSet.Entity1ToLink.PK #> = linkEntity.<#= associationSet.Entity1ToLink.FK #> };
            }
			
			ObjectStateEntry end1StateEntry;
			
            EntityKey end1Key = ObjectContext.CreateEntityKey("<#= associationSet.Entity1ToLink.Entity.EntitySet #>", end1Entity);
			
			// Check to see if <#= associationSet.Entity1ToLink.Entity.Name #> is already being tracked by they current entity framework object context.
            ObjectContext.ObjectStateManager.TryGetObjectStateEntry(end1Key, out end1StateEntry);

			if (end1StateEntry != null && end1StateEntry.State != EntityState.Detached)
            {
                // If <#= associationSet.Entity1ToLink.Entity.Name #> is already being tracked by the object context, then use the instance of <#= associationSet.Entity1ToLink.Entity.Name #> that is being tracked instead of the current <#= associationSet.Entity1ToLink.Entity.Name #>
                end1Entity = end1StateEntry.Entity as <#= associationSet.Entity1ToLink.Entity.Name #>;
            }
				
			// ** Process <#= associationSet.Entity2ToLink.Entity.Name #> **
            <#= associationSet.Entity2ToLink.Entity.Name #> end2Entity;

            if (linkEntity.<#= associationSet.Entity2ToLink.Entity.Name #> != null)
            {
                // If a reference of <#= associationSet.Entity2ToLink.Entity.Name #> is in the linkEntity that has been passed to this method, then get it.
                end2Entity = linkEntity.<#= associationSet.Entity2ToLink.Entity.Name #>;
            }
            else
            {
                // If there is no reference to <#= associationSet.Entity2ToLink.Entity.Name #> in the linkEntity, then build <#= associationSet.Entity2ToLink.Entity.Name #> from the <#= associationSet.Entity2ToLink.FK #> that has been passed in the linkEntity.
                //
				// Note: In the situation where the entity that we are dealing with is abstract, then use one of it's 
				// derived entities to act as the concrete type for the end.  A derived entity is used in this situation 
				// because you can't instantiate an abstract entity.  The derived entity that you use is not important,
				// since all derived entities will posses the same many to many relationship from the base entity.
				end2Entity = new <#= end2ConcreteEntity #>() { <#= associationSet.Entity2ToLink.PK #> = linkEntity.<#= associationSet.Entity2ToLink.FK #> };
            }
		
			ObjectStateEntry end2StateEntry;
            
			EntityKey end2Key = ObjectContext.CreateEntityKey("<#= associationSet.Entity2ToLink.Entity.EntitySet #>", end2Entity);

            // Check to see if <#= associationSet.Entity2ToLink.Entity.Name #> is already being tracked by they current entity framework object context.
            ObjectContext.ObjectStateManager.TryGetObjectStateEntry(end2Key, out end2StateEntry);

            if (end2StateEntry != null && end2StateEntry.State != EntityState.Detached)
            {
                // If <#= associationSet.Entity2ToLink.Entity.Name #> is already being tracked by the object context, then use the instance of <#= associationSet.Entity2ToLink.Entity.Name #> that is being tracked instead of the current <#= associationSet.Entity2ToLink.Entity.Name #>
                end2Entity = end2StateEntry.Entity as <#= associationSet.Entity2ToLink.Entity.Name #>;
            }
	
<# 
				if(associationSet.Entity1ToLink.HasM2MNavProp)
				{
#>
			// ** Attach <#= associationSet.Entity1ToLink.Entity.Name #> to the Object Context if it wasnt already attached **
            if (end1StateEntry == null || end1StateEntry.State == EntityState.Detached)
            {
                // Build many to many relationship between <#= associationSet.Entity1ToLink.Entity.Name #> and <#= associationSet.Entity2ToLink.Entity.Name #> so it can be removed after being attached.
                end1Entity.<#= associationSet.Entity1ToLink.M2MNavProp #>.Add(end2Entity);

                // Attach <#= associationSet.Entity1ToLink.Entity.Name #> (<#= associationSet.Entity2ToLink.Entity.Name #> will be attached indrectly through this method)
                ObjectContext.AttachTo("<#= associationSet.Entity1ToLink.Entity.EntitySet #>", end1Entity);
            }

            // ** Remove Relationship **
            end1Entity.<#= associationSet.Entity1ToLink.M2MNavProp #>.Remove(end2Entity);
<#
				}
				else
				{
#>
			// ** Attach <#= associationSet.Entity2ToLink.Entity.Name #> to the Object Context if it wasnt already attached **
            if (end2StateEntry == null || end2StateEntry.State == EntityState.Detached)
            {
                // Build many to many relationship between <#= associationSet.Entity2ToLink.Entity.Name #> and <#= associationSet.Entity1ToLink.Entity.Name #> so it can be removed after being attached.
                end2Entity.<#= associationSet.Entity2ToLink.M2MNavProp #>.Add(end1Entity);

                // Attach <#= associationSet.Entity2ToLink.Entity.Name #> (<#= associationSet.Entity1ToLink.Entity.Name #> will be attached indrectly through this method)
                ObjectContext.AttachTo("<#= associationSet.Entity2ToLink.Entity.EntitySet #>", end2Entity);
            }

            // ** Remove Relationship **
            end2Entity.<#= associationSet.Entity2ToLink.M2MNavProp #>.Remove(end1Entity);
<#
				}
#>
		
		}
		
<# 
			}
		}
#>

	}
}

#endregion

#pragma warning restore 618

