<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#   
//
// Change the file path below to the path of the M2M4RiaShared.ttinclude in your project
//
#>
<#@ include file="..\Shared\M2M4RiaShared.ttinclude" #>
<#

M2MData m2mData = GenerateM2MData();

#> 

// Instruct compiler not to warn about usage of obsolete members, because using them is intended.
#pragma warning disable 618

#region Domain Service

namespace <#= DomainServiceNamespace #>
{
	using System;
	using System.Linq;
	using System.Data;
	using System.Data.Objects;
	using System.Data.Objects.DataClasses;
	
	using <#= EntityModelNamespace #>;
	
	/// <summary>
    /// This class defines Create and Delete operations for the following many-2-many relation(s):
	///
<#
	foreach(M2MAssociationSet associationSet in m2mData.Associations)
	{
		if(associationSet.Entity1ToLink.HasM2MNavProp || associationSet.Entity2ToLink.HasM2MNavProp)
		{
#>
    ///   <#=associationSet.Entity1ToLink.Entity.Name #> <--> <#=associationSet.Entity2ToLink.Entity.Name #>
<#
		}
	}
#>
	/// 
    /// We use stub entities to represent entities for which only the foreign key property is available in join type objects.
    /// 
    /// Note: If an entity type is abstract, we use one of its derived entities to act as the concrete type for the stub entity, 
    /// because we can't instantiate the abstract type. The derived entity type that we use is not important, since all derived 
    /// entities types will posses the same many to many relationship from the base entity.
    /// </summary>
	public partial class <#= DomainServiceName #>
	{
<# 
		foreach(M2MAssociationSet associationSet in m2mData.Associations)
		{
			// If the entities on either side of the M2M relationship don't have a navigation property to each other, then there is no need to output this.
			if(associationSet.Entity1ToLink.HasM2MNavProp || associationSet.Entity2ToLink.HasM2MNavProp)
			{
				MakeInsertOperation(associationSet);
				MakeDeleteOperation(associationSet);
			}
		}
#>

#region GetEntityByKey
        /// <summary>
        /// http://blogs.msdn.com/b/alexj/archive/2009/06/19/tip-26-how-to-avoid-database-queries-using-stub-entities.aspx
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="ctx"></param>
        /// <param name="qualifiedEntitySetName"></param>
        /// <param name="stubEntity"></param>
        /// <returns></returns>
        private static T GetEntityByKey<T>(ObjectContext ctx, string qualifiedEntitySetName, T stubEntity) where T : EntityObject
        {
            ObjectStateEntry state;
            EntityKey key = ctx.CreateEntityKey(qualifiedEntitySetName, stubEntity);
            if (ctx.ObjectStateManager.TryGetObjectStateEntry(key, out state) == false)
            {
                ctx.AttachTo(qualifiedEntitySetName, stubEntity);
                return stubEntity;
            }
            else
            {
                return (T)state.Entity;
            }
        }
#endregion

	}
}

#endregion

// Restore compiler warnings when using obsolete methods
#pragma warning restore 618

<#+
private void MakeInsertOperation(M2MAssociationSet associationSet)
{
	string end1Entity = LowerInitial(associationSet.Entity1ToLink.Entity.Name);
	string end2Entity = LowerInitial(associationSet.Entity2ToLink.Entity.Name);
	string linkEntityName = LowerInitial(associationSet.Name);
#>
		[Obsolete("This method is only intended for use by the RIA M2M solution")]
		public void Insert<#= associationSet.Name #>(<#= associationSet.Name #> <#= linkEntityName #>)
		{
<#+
		MakeGetType(associationSet.Entity1ToLink, linkEntityName); 
		MakeGetType(associationSet.Entity2ToLink, linkEntityName); 
		if(associationSet.Entity1ToLink.HasM2MNavProp)
		{
#>
			<#=end1Entity#>.<#= associationSet.Entity1ToLink.M2MNavProp #>.Add(<#=end2Entity#>);
<#+
		}
		else
		{
#>
         <#=end2Entity#>.<#= associationSet.Entity2ToLink.M2MNavProp #>.Add(<#=end1Entity#>;
<#+
		}
#>
		}
<#+
}
private void MakeDeleteOperation(M2MAssociationSet associationSet)
{		
	string end1Entity = LowerInitial(associationSet.Entity1ToLink.Entity.Name);
	string end2Entity = LowerInitial(associationSet.Entity2ToLink.Entity.Name);
	string linkEntityName = LowerInitial(associationSet.Name);

#>
		[Obsolete("This method is only intended for use by the RIA M2M solution")]
		public void Delete<#= associationSet.Name #>(<#= associationSet.Name #> <#= linkEntityName #>)
		{
<#+			
		MakeGetType(associationSet.Entity1ToLink, linkEntityName); 
		MakeGetType(associationSet.Entity2ToLink, linkEntityName); 
		if(associationSet.Entity1ToLink.HasM2MNavProp)
		{
#>
			<#=end1Entity#>.<#= associationSet.Entity1ToLink.M2MNavProp #>.Remove(<#=end2Entity#>);
<#+
		}
		else
		{
#>
			<#=end2Entity#>.<#= associationSet.Entity2ToLink.M2MNavProp #>.Remove(<#=end1Entity#>);
<#+
		}
#>
		}
<#+
}
private void MakeGetType(M2MAssociation association, string linkEntityName) 
{
	string entityType = association.Entity.Name;
	string entity = LowerInitial(entityType);
	string concreteEntityType = association.Entity.IsAbstract ? association.Entity.DerivedEntityNames[0] : association.Entity.Name;
	string stubEntity = entity + "StubEntity";
#>
			<#= entityType #> <#=entity#> = <#= linkEntityName #>.<#= entityType #>;			
			if(<#=entity#> == null)
			{
				<#= entityType #> <#=stubEntity#> = new <#= concreteEntityType  #>() { <#= association.PK #> = <#= linkEntityName #>.<#= association.FK #> };
				<#=entity#> = GetEntityByKey<<#=association.Entity.Name#>>(ObjectContext, "<#=association.Entity.EntitySet#>", <#=stubEntity#>);
			}							
<#+
}
private string LowerInitial(string name)
{
   return name[0].ToString().ToLowerInvariant() + name.Substring(1);
}
#>