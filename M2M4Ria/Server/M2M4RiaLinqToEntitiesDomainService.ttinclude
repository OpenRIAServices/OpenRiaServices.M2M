<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#
//
// Change the file path below to the path of the M2M4RiaShared.ttinclude in your project
//
#>
<#@ include file="..\Shared\M2M4RiaShared.ttinclude" #>
<#

M2MData m2mData = GenerateM2MData();

#>

// Instruct compiler not to warn about usage of obsolete members, because using them is intended.
#pragma warning disable 618

#region Domain Service

namespace <#= DomainServiceNamespace #>
{
    using System;
    using System.Data;
    using System.Data.Objects;
    using System.Data.Objects.DataClasses;
	using System.Linq;
<#
    if(EntityModelNamespace != DomainServiceNamespace)
    {
#>
    using <#= EntityModelNamespace #>;
<#
    }
#>
	
    /// <summary>
    /// This class defines Create and Delete operations for the following many-2-many relation(s):
    ///
<#
    foreach(M2MAssociationSet associationSet in m2mData.Associations)
    {
        if(associationSet.Entity1ToLink.HasM2MNavProp || associationSet.Entity2ToLink.HasM2MNavProp)
        {
#>
    ///   <#=associationSet.Entity1ToLink.Entity.Name #> <--> <#=associationSet.Entity2ToLink.Entity.Name #>
<#
        }
    }
#>
    ///
    /// We use stub entities to represent entities for which only the foreign key property is available in join type objects.
    ///
    /// Note: If an entity type is abstract, we use one of its derived entities to act as the concrete type for the stub entity,
    /// because we can't instantiate the abstract type. The derived entity type that we use is not important, since all derived
    /// entities types will posses the same many to many relationship from the base entity.
    ///
    /// Note: We generate Update operations for the join types to deal with a WCF RIA bug (http://forums.silverlight.net/forums/p/201613/470578.aspx#470578).
    /// Update operations are really not needed and also not used.
    /// </summary>
    public partial class <#= DomainServiceName #>
    {
<#
        foreach(M2MAssociationSet associationSet in m2mData.Associations)
        {
            // If the entities on either side of the M2M relationship don't have a navigation property to each other, then there is no need to output this.
            if(associationSet.Entity1ToLink.HasM2MNavProp || associationSet.Entity2ToLink.HasM2MNavProp)
            {
                MakeUpdateOperation(associationSet);
                MakeInsertOperation(associationSet);
                MakeDeleteOperation(associationSet);
            }
        }
#>

#region GetEntityByKey
        /// <summary>
        /// http://blogs.msdn.com/b/alexj/archive/2009/06/19/tip-26-how-to-avoid-database-queries-using-stub-entities.aspx
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="ctx"></param>
        /// <param name="qualifiedEntitySetName"></param>
        /// <param name="stubEntity"></param>
        /// <returns></returns>
        private static T GetEntityByKey<T>(ObjectContext ctx, string qualifiedEntitySetName, T stubEntity)
        {
            ObjectStateEntry state;
            EntityKey key = ctx.CreateEntityKey(qualifiedEntitySetName, stubEntity);
            if (ctx.ObjectStateManager.TryGetObjectStateEntry(key, out state) == false)
            {
                ctx.AttachTo(qualifiedEntitySetName, stubEntity);
                return stubEntity;
            }
            else
            {
                return (T)state.Entity;
            }
        }
#endregion
    }
}

#endregion

// Restore compiler warnings when using obsolete methods
#pragma warning restore 618

<#+
private void MakeUpdateOperation(M2MAssociationSet associationSet)
{
    string linkEntityName = LowerInitial(associationSet.Name);
#>
        [Obsolete("This method is only intended for use by the RIA M2M solution")]
        public void Update<#= associationSet.Name #>(<#= associationSet.Name #> <#= linkEntityName #>)
        {
            throw new NotSupportedException("Update operation on <#= associationSet.Name #> is not supported.");
        }
<#+
}
private void MakeInsertOperation(M2MAssociationSet associationSet)
{
    string end1Entity = LowerInitial(associationSet.Entity1ToLink.Entity.Name);
    string end2Entity = LowerInitial(associationSet.Entity2ToLink.Entity.Name);
    string linkEntityName = LowerInitial(associationSet.Name);
#>
        [Obsolete("This method is only intended for use by the RIA M2M solution")]
        public void Insert<#= associationSet.Name #>(<#= associationSet.Name #> <#= linkEntityName #>)
        {
<#+
        MakeGetType(associationSet.Entity1ToLink, linkEntityName);
        MakeGetType(associationSet.Entity2ToLink, linkEntityName);
        if(associationSet.Entity1ToLink.HasM2MNavProp)
        {
#>
            <#=end1Entity#>.<#= associationSet.Entity1ToLink.M2MNavProp #>.Add(<#=end2Entity#>);
<#+
        }
        else
        {
#>
            <#=end2Entity#>.<#= associationSet.Entity2ToLink.M2MNavProp #>.Add(<#=end1Entity#>);
<#+
        }
#>
        }
<#+
}
private void MakeDeleteOperation(M2MAssociationSet associationSet)
{
    string end1Entity = LowerInitial(associationSet.Entity1ToLink.Entity.Name);
    string end2Entity = LowerInitial(associationSet.Entity2ToLink.Entity.Name);
    string linkEntityName = LowerInitial(associationSet.Name);

#>
        [Obsolete("This method is only intended for use by the RIA M2M solution")]
        public void Delete<#= associationSet.Name #>(<#= associationSet.Name #> <#= linkEntityName #>)
        {
<#+
        MakeGetType(associationSet.Entity1ToLink, linkEntityName);
        MakeGetType(associationSet.Entity2ToLink, linkEntityName);
        if(associationSet.Entity1ToLink.HasM2MNavProp)
        {
		   MakeRemove(associationSet.Entity1ToLink, end2Entity);
	    }
		else
		{
		   MakeRemove(associationSet.Entity2ToLink, end1Entity);
	    }
#>
        }
<#+
}
private void MakeRemove(M2MAssociation association, string entity)
{
    string parentEntity = LowerInitial(association.Entity.Name);
#>
            if(<#=parentEntity#>.<#= association.M2MNavProp #>.IsLoaded == false)
            {
			    // We can't attach <#=entity#> if <#=parentEntity#> is deleted. In that case we
				// temporarily reset the entity state of <#=parentEntity#>, then attach <#=entity#>
				// and set the entity state of <#=parentEntity#> back to EntityState.Deleted.
                ObjectStateEntry stateEntry = ObjectContext.ObjectStateManager.GetObjectStateEntry(<#=parentEntity#>);
                EntityState state = stateEntry.State;

                if(state == EntityState.Deleted)
                {
                    stateEntry.ChangeState(EntityState.Unchanged);
                }
                <#=parentEntity#>.<#= association.M2MNavProp #>.Attach(<#=entity#>);
                if(stateEntry.State != state)
                {
                    stateEntry.ChangeState(state);
                }
            }
            <#=parentEntity#>.<#= association.M2MNavProp #>.Remove(<#=entity#>);
<#+
}
private void MakeGetType(M2MAssociation association, string linkEntityName)
{
    string entityType = association.Entity.Name;
    string entity = LowerInitial(entityType);
    string concreteEntityType = association.Entity.IsAbstract ? association.Entity.DerivedEntityNames[0] : association.Entity.Name;
    string stubEntity = entity + "StubEntity";
#>
            <#= entityType #> <#=entity#> = <#= linkEntityName #>.<#= entityType #>;
            if(<#=entity#> == null)
            {
			   <#=entity#> = ChangeSet.ChangeSetEntries.Select(cse => cse.Entity)
			      .OfType<<#= concreteEntityType #>>()
				  .SingleOrDefault(e => e.<#= association.PK #> == <#= linkEntityName #>.<#= association.FK #> );
			}
            if(<#=entity#> == null)
            {
                <#= entityType #> <#=stubEntity#> = new <#= concreteEntityType #> { <#= association.PK #> = <#= linkEntityName #>.<#= association.FK #> };
                <#=entity#> = GetEntityByKey<<#=association.Entity.Name#>>(ObjectContext, "<#=association.Entity.EntitySet#>", <#=stubEntity#>);
            }
<#+
}
private string LowerInitial(string name)
{
   return name[0].ToString().ToLowerInvariant() + name.Substring(1);
}
#>