<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#   
//
// Change the file path below to the path of the RIAM2MShared.ttinclude in your project
//
#>
<#@ include file="$(SolutionDir)\M2M4Ria\Shared\RIAM2MShared.ttinclude" #>
<#

M2MData m2mData = GenerateM2MData();

#> 

#pragma warning disable 618

#region Domain Service

namespace <#= DomainServiceNamespace #>
{
	using System;
	using System.Linq;
	using System.Data;
	using System.Data.Objects;
	using System.Data.Objects.DataClasses;
	
	using <#= EntityModelNamespace #>;
	
	public partial class <#= DomainServiceName #>
	{
<# 
		foreach(M2MAssociationSet associationSet in m2mData.Associations)
		{
			// If the entities on either side of the M2M relationship don't have a navigation property to each other, then there is no need to output this.
			if(associationSet.Entity1ToLink.HasM2MNavProp || associationSet.Entity2ToLink.HasM2MNavProp)
			{
				MakeInsertOperation(associationSet);
				MakeDeleteOperation(associationSet);
			}
		}
#>

#region GetEntityByKey
        /// <summary>
        /// http://blogs.msdn.com/b/alexj/archive/2009/06/19/tip-26-how-to-avoid-database-queries-using-stub-entities.aspx
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="ctx"></param>
        /// <param name="qualifiedEntitySetName"></param>
        /// <param name="stubEntity"></param>
        /// <returns></returns>
        private static T GetEntityByKey<T>(ObjectContext ctx, string qualifiedEntitySetName, T stubEntity) where T : EntityObject
        {
            ObjectStateEntry state;
            EntityKey key = ctx.CreateEntityKey(qualifiedEntitySetName, stubEntity);
            if (ctx.ObjectStateManager.TryGetObjectStateEntry(key, out state) == false)
            {
                ctx.AttachTo(qualifiedEntitySetName, stubEntity);
                return stubEntity;
            }
            else
            {
                return (T)state.Entity;
            }
        }
#endregion

	}
}

#endregion


#pragma warning restore 618

<#+
private void MakeInsertOperation(M2MAssociationSet associationSet)
{
	string end1Entity = LowerInitial(associationSet.Entity1ToLink.Entity.Name);
	string end2Entity = LowerInitial(associationSet.Entity2ToLink.Entity.Name);
#>
	[Obsolete("This method is only intended for use by the RIA M2M solution")]
	public void Insert<#= associationSet.Name #>(<#= associationSet.Name #> linkEntity)
	{
<#+
		MakeGetType(associationSet.Entity1ToLink); 
		MakeGetType(associationSet.Entity2ToLink); 
		if(associationSet.Entity1ToLink.HasM2MNavProp)
		{
#>
		<#=end1Entity#>.<#= associationSet.Entity1ToLink.M2MNavProp #>.Add(<#=end2Entity#>);
<#+
		}
		else
		{
#>
		<#=end2Entity#>.<#= associationSet.Entity2ToLink.M2MNavProp #>.Add(<#=end1Entity#>;
<#+
		}
#>
	}
<#+
}
private void MakeDeleteOperation(M2MAssociationSet associationSet)
{		
	string end1Entity = LowerInitial(associationSet.Entity1ToLink.Entity.Name);
	string end2Entity = LowerInitial(associationSet.Entity2ToLink.Entity.Name);
#>
	[Obsolete("This method is only intended for use by the RIA M2M solution")]
	public void Delete<#= associationSet.Name #>(<#= associationSet.Name #> linkEntity)
	{
<#+			
		MakeGetType(associationSet.Entity1ToLink); 
		MakeGetType(associationSet.Entity2ToLink); 
		if(associationSet.Entity1ToLink.HasM2MNavProp)
		{
#>
			<#=end1Entity#>.<#= associationSet.Entity1ToLink.M2MNavProp #>.Remove(<#=end2Entity#>);
<#+
		}
		else
		{
#>
			<#=end2Entity#>.<#= associationSet.Entity2ToLink.M2MNavProp #>.Remove(<#=end1Entity#>);
<#+
		}
#>		
		}
<#+
}
private void MakeGetType(M2MAssociation association) 
{
	string entityType = association.Entity.Name;
	string entity = LowerInitial(entityType);
	string concreteEntityType = association.Entity.IsAbstract ? association.Entity.DerivedEntityNames[0] : association.Entity.Name;
	string stubEntity = LowerInitial(concreteEntityType) + "StubEntity";
#>
			// ** Process <#= association.Entity.Name #> end **
			<#= entityType #> <#=entity#>;
			
			if (linkEntity.<#= entityType #> != null)
			{
				// If a reference of <#= entityType #> is in the linkEntity that has been passed to this method, then get it.
				<#=entity#> = linkEntity.<#= entityType #>;
			}
			else
			{
				// If there is no reference to <#= entityType #> in the linkEntity, then build <#= entityType #> 
				// from the <#= association.FK #> that has been passed in the linkEntity.
				//
				// Note: In the situation where the entity that we are dealing with is abstract, then use one of it's 
				// derived entities to act as the concrete type for the end.  A derived entity is used in this situation 
				// because you can't instantiate an abstract entity.  The derived entity that you use is not important,
				// since all derived entities will posses the same many to many relationship from the base entity.
				<#= entityType #> <#=stubEntity#> = new <#= concreteEntityType  #>() { <#= association.PK #> = linkEntity.<#= association.FK #> };
				<#=entity#> = GetEntityByKey<<#=association.Entity.Name#>>(ObjectContext, "<#=association.Entity.EntitySet#>", <#=stubEntity#>);
			}							
<#+
}
private string LowerInitial(string name)
{
   return name[0].ToString().ToLowerInvariant() + name.Substring(1);
}
#>